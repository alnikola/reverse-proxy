<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>HTTP Client Configuration </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="HTTP Client Configuration ">
    <meta name="generator" content="docfx 2.58.0.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="http-client-configuration">HTTP Client Configuration</h1>

<p>Introduced: preview5</p>
<h2 id="introduction">Introduction</h2>
<p>Each <a class="xref" href="../api/Yarp.ReverseProxy.Configuration.ClusterConfig.html">Cluster</a> has a dedicated <a href="https://docs.microsoft.com/dotnet/api/system.net.http.httpmessageinvoker">HttpMessageInvoker</a> instance used to forward requests to its <a class="xref" href="../api/Yarp.ReverseProxy.Configuration.DestinationConfig.html">Destination</a>s. The configuration is defined per cluster. On YARP startup, all clusters get new <code>HttpMessageInvoker</code> instances, however if later the cluster configuration gets changed the <a class="xref" href="../api/Yarp.ReverseProxy.Forwarder.IForwarderHttpClientFactory.html">IForwarderHttpClientFactory</a> will re-run and decide if it should create a new <code>HttpMessageInvoker</code> or keep using the existing one. The default <code>IForwarderHttpClientFactory</code> implementation creates a new <code>HttpMessageInvoker</code> when there are changes to the <a class="xref" href="../api/Yarp.ReverseProxy.Configuration.HttpClientConfig.html">HttpClientConfig</a>.</p>
<p>Properties of outgoing requests for a given cluster can be configured as well. They are defined in <a class="xref" href="../api/Yarp.ReverseProxy.Forwarder.ForwarderRequestConfig.html">ForwarderRequestConfig</a>.</p>
<p>The configuration is represented differently if you're using the <a href="https://docs.microsoft.com/dotnet/api/microsoft.extensions.configuration.iconfiguration">IConfiguration</a> model or the code-first model.</p>
<h2 id="iconfiguration">IConfiguration</h2>
<p>These types are focused on defining serializable configuration. The code based configuration model is described below in the &quot;Code Configuration&quot; section.</p>
<h3 id="httpclient">HttpClient</h3>
<p>HTTP client configuration is based on <a class="xref" href="../api/Yarp.ReverseProxy.Configuration.HttpClientConfig.html">HttpClientConfig</a> and represented by the following configuration schema.</p>
<pre><code class="lang-JSON">&quot;HttpClient&quot;: {
    &quot;SslProtocols&quot;: [ &quot;&lt;protocol-names&gt;&quot; ],
    &quot;MaxConnectionsPerServer&quot;: &quot;&lt;int&gt;&quot;,
    &quot;DangerousAcceptAnyServerCertificate&quot;: &quot;&lt;bool&gt;&quot;,
    &quot;RequestHeaderEncoding&quot;: &quot;&lt;encoding-name&gt;&quot;,
    &quot;EnableMultipleHttp2Connections&quot;: &quot;&lt;bool&gt;&quot;
}
</code></pre>
<p>Configuration settings:</p>
<ul>
<li>SslProtocols - <a href="https://docs.microsoft.com/dotnet/api/system.security.authentication.sslprotocols">SSL protocols</a> enabled on the given HTTP client. Protocol names are specified as array of strings. Default value is <a href="https://docs.microsoft.com/dotnet/api/system.security.authentication.sslprotocols#System_Security_Authentication_SslProtocols_None">None</a>.</li>
</ul>
<pre><code class="lang-JSON">&quot;SslProtocols&quot;: [
    &quot;Tls11&quot;,
    &quot;Tls12&quot;
]
</code></pre>
<ul>
<li>MaxConnectionsPerServer - maximal number of HTTP 1.1 connections open concurrently to the same server. Default value is <a href="https://docs.microsoft.com/dotnet/api/system.int32.maxvalue">int32.MaxValue</a>.</li>
</ul>
<pre><code class="lang-JSON">&quot;MaxConnectionsPerServer&quot;: &quot;10&quot;
</code></pre>
<ul>
<li>DangerousAcceptAnyServerCertificate - indicates whether the server's SSL certificate validity is checked by the client. Setting it to <code>true</code> completely disables validation. Default value is <code>false</code>.</li>
</ul>
<pre><code class="lang-JSON">&quot;DangerousAcceptAnyServerCertificate&quot;: &quot;true&quot;
</code></pre>
<ul>
<li>RequestHeaderEncoding - enables other than ASCII encoding for outgoing request headers. Setting this value will leverage <a href="https://docs.microsoft.com/dotnet/api/system.net.http.socketshttphandler.requestheaderencodingselector"><code>SocketsHttpHandler.RequestHeaderEncodingSelector</code></a> and use the selected encoding for all headers. If you need more granular approach, please use custom <code>IProxyHttpClientFactory</code>. The value is then parsed by <a href="https://docs.microsoft.com/dotnet/api/system.text.encoding.getencoding#System_Text_Encoding_GetEncoding_System_String_"><code>Encoding.GetEncoding</code></a>, use values like: &quot;utf-8&quot;, &quot;iso-8859-1&quot;, etc. <strong>This setting is only available for .NET 5.0.</strong></li>
</ul>
<pre><code class="lang-JSON">&quot;RequestHeaderEncoding&quot;: &quot;utf-8&quot;
</code></pre>
<p>If you're using an encoding other than ASCII (or UTF-8 for Kestrel) you also need to set your server to accept requests with such headers. For example, use <a href="https://docs.microsoft.com/dotnet/api/Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions.RequestHeaderEncodingSelector"><code>KestrelServerOptions.RequestHeaderEncodingSelector</code></a> to set up Kestrel to accept Latin1 (&quot;iso-8859-1&quot;) headers:</p>
<pre><code class="lang-C#">private static IHostBuilder CreateHostBuilder(string[] args) =&gt;
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =&gt;
        {
            webBuilder.UseStartup&lt;Startup&gt;()
                      .ConfigureKestrel(kestrel =&gt;
                      {
                          kestrel.RequestHeaderEncodingSelector = _ =&gt; Encoding.Latin1;
                      });
        );
</code></pre>
<ul>
<li>EnableMultipleHttp2Connections - enables opening additional HTTP/2 connections to the same server when the maximum number of concurrent streams is reached on all existing connections. The default is <code>true</code>. <strong>This feature is available from .NET 5.0</strong>, see <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.socketshttphandler.enablemultiplehttp2connections">SocketsHttpHandler.EnableMultipleHttp2Connections</a></li>
</ul>
<pre><code class="lang-JSON">&quot;EnableMultipleHttp2Connections&quot;: false
</code></pre>
<p>For .NET Core 3.1, Latin1 (&quot;iso-8859-1&quot;) is the only non-ASCII header encoding that can be accepted and only via <code>appsettings.json</code>:</p>
<pre><code class="lang-JSON">{
    &quot;Kestrel&quot;:
    {
        &quot;Latin1RequestHeaders&quot;: true
    }
}
</code></pre>
<p>together with an application wide switch:</p>
<pre><code class="lang-C#">AppContext.SetSwitch(&quot;System.Net.Http.SocketsHttpHandler.AllowLatin1Headers&quot;, true);
</code></pre>
<p>At the moment, there is no solution for changing encoding for response headers in Kestrel (see <a href="https://github.com/dotnet/aspnetcore/issues/26334">aspnetcore#26334</a>), only ASCII is accepted.</p>
<h3 id="httprequest">HttpRequest</h3>
<p>HTTP request configuration is based on <a class="xref" href="../api/Yarp.ReverseProxy.Forwarder.ForwarderRequestConfig.html">ForwarderRequestConfig</a> and represented by the following configuration schema.</p>
<pre><code class="lang-JSON">&quot;HttpRequest&quot;: {
    &quot;Timeout&quot;: &quot;&lt;timespan&gt;&quot;,
    &quot;Version&quot;: &quot;&lt;string&gt;&quot;,
    &quot;VersionPolicy&quot;: [&quot;RequestVersionOrLower&quot;, &quot;RequestVersionOrHigher&quot;, &quot;RequestVersionExact&quot;],
    &quot;AllowResponseBuffering&quot;: &quot;&lt;bool&gt;&quot;
}
</code></pre>
<p>Configuration settings:</p>
<ul>
<li>Timeout - the timeout for the outgoing request sent by <a href="https://docs.microsoft.com/dotnet/api/system.net.http.httpmessageinvoker.sendasync">HttpMessageInvoker.SendAsync</a>. If not specified, 100 seconds is used.</li>
<li>Version - outgoing request <a href="https://docs.microsoft.com/dotnet/api/system.net.http.httprequestmessage.version">version</a>. The supported values at the moment are <code>1.0</code>, <code>1.1</code> and <code>2</code>. Default value is 2.</li>
<li>VersionPolicy - defines how the final version is selected for the outgoing requests. <strong>This feature is available from .NET 5.0</strong>, see <a href="https://docs.microsoft.com/dotnet/api/system.net.http.httprequestmessage.versionpolicy">HttpRequestMessage.VersionPolicy</a>. The default value is <code>RequestVersionOrLower</code>.</li>
<li>AllowResponseBuffering - allows to use write buffering when sending a response back to the client, if the server hosting YARP (e.g. IIS) supports it. <strong>NOTE</strong>: enabling it can break SSE (server side event) scenarios.</li>
</ul>
<h2 id="configuration-example">Configuration example</h2>
<p>The below example shows 2 samples of HTTP client and request configurations for <code>cluster1</code> and <code>cluster2</code>.</p>
<pre><code class="lang-JSON">{
    &quot;Clusters&quot;: {
        &quot;cluster1&quot;: {
            &quot;LoadBalancingPolicy&quot;: &quot;Random&quot;,
            &quot;HttpClient&quot;: {
                &quot;SslProtocols&quot;: [
                    &quot;Tls11&quot;,
                    &quot;Tls12&quot;
                ],
                &quot;MaxConnectionsPerServer&quot;: &quot;10&quot;,
                &quot;DangerousAcceptAnyServerCertificate&quot;: &quot;true&quot;
            },
            &quot;HttpRequest&quot;: {
                &quot;Timeout&quot;: &quot;00:00:30&quot;
            },
            &quot;Destinations&quot;: {
                &quot;cluster1/destination1&quot;: {
                    &quot;Address&quot;: &quot;https://localhost:10000/&quot;
                },
                &quot;cluster1/destination2&quot;: {
                    &quot;Address&quot;: &quot;http://localhost:10010/&quot;
                }
            }
        },
        &quot;cluster2&quot;: {
            &quot;HttpClient&quot;: {
                &quot;SslProtocols&quot;: [
                    &quot;Tls12&quot;
                ]
            },
            &quot;HttpRequest&quot;: {
                &quot;Version&quot;: &quot;1.1&quot;,
                &quot;VersionPolicy&quot;: &quot;RequestVersionExact&quot;
            },
            &quot;Destinations&quot;: {
                &quot;cluster2/destination1&quot;: {
                    &quot;Address&quot;: &quot;https://localhost:10001/&quot;
                }
            }
        }
    }
}
</code></pre>
<h2 id="code-configuration">Code Configuration</h2>
<p>HTTP client configuration uses the type <a class="xref" href="../api/Yarp.ReverseProxy.Configuration.HttpClientConfig.html">HttpClientConfig</a>.</p>
<p>The following is an example of <code>HttpClientConfig</code> using <a href="config-providers.html">code based</a> configuration. An instance of <code>HttpClientConfig</code> is assigned to the <a class="xref" href="../api/Yarp.ReverseProxy.Configuration.ClusterConfig.html">ClusterConfig.HttpClient</a> property before passing the cluster array to <code>LoadFromMemory</code> method.</p>
<pre><code class="lang-C#">public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
    var routes = new[]
    {
        new RouteConfig()
        {
            RouteId = &quot;route1&quot;,
            ClusterId = &quot;cluster1&quot;,
            Match =
            {
                Path = &quot;{**catch-all}&quot;
            }
        }
    };
    var clusters = new[]
    {
        new ClusterConfig()
        {
            ClusterId = &quot;cluster1&quot;,
            Destinations =
            {
                { &quot;destination1&quot;, new DestinationConfig() { Address = &quot;https://localhost:10000&quot; } }
            },
            HttpClient = new HttpClientConfig { MaxConnectionsPerServer = 10, SslProtocols = SslProtocols.Tls11 | SslProtocols.Tls12 }
        }
    };

    services.AddReverseProxy()
        .LoadFromMemory(routes, clusters)
        .AddProxyConfigFilter&lt;CustomConfigFilter&gt;();
}
</code></pre>
<h2 id="configuring-the-http-client">Configuring the http client</h2>
<p><code>ConfigureHttpClient</code> provides a callback to customize the <code>SocketsHttpHandler</code> settings used for proxying requests. This will be called each time a cluster is added or changed. Cluster settings are applied to the handler before the callback. Custom data can be provided in the cluster metadata. This example shows adding a client certificate that will authenticate the proxy to the destination servers.</p>
<pre><code class="lang-C#">    var clientCert = new X509Certificate2(&quot;path&quot;);
    services.AddReverseProxy()
        .ConfigureHttpClient((context, handler) =&gt;
        {
            handler.SslOptions.ClientCertificates.Add(clientCert);
        })
</code></pre>
<h2 id="custom-iforwarderhttpclientfactory">Custom IForwarderHttpClientFactory</h2>
<p>If direct control of HTTP client construction is necessary, the default <a class="xref" href="../api/Yarp.ReverseProxy.Forwarder.IForwarderHttpClientFactory.html">IForwarderHttpClientFactory</a> can be replaced with a custom one. For some customizations you can derive from the default <a href="xref:Yarp.ReverseProxy.Service.Proxy.Infrastructure.ProxyHttpClientFactory">ProxyHttpClientFactory</a> and override the methods that configure the client.</p>
<p>It's recommended that any custom factory set the following <code>SocketsHttpHandler</code> properties to the same values as the default factory does in order to preserve a correct reverse proxy behavior and avoid unnecessary overhead.</p>
<pre><code class="lang-C#">new SocketsHttpHandler
{
    UseProxy = false,
    AllowAutoRedirect = false,
    AutomaticDecompression = DecompressionMethods.None,
    UseCookies = false
};
</code></pre>
<p>Always return an HttpMessageInvoker instance rather than an HttpClient instance which derives from HttpMessageInvoker. HttpClient buffers responses by default which breaks streaming scenarios and increases memory usage and latency.</p>
<p>Custom data can be provided in the cluster metadata.</p>
<p>The below is an example of a custom <code>IForwarderHttpClientFactory</code> implementation.</p>
<pre><code class="lang-C#">public class CustomForwarderHttpClientFactory : IForwarderHttpClientFactory
{
    public HttpMessageInvoker CreateClient(ForwarderHttpClientContext context)
    {
        var handler = new SocketsHttpHandler
        {
            UseProxy = false,
            AllowAutoRedirect = false,
            AutomaticDecompression = DecompressionMethods.None,
            UseCookies = false
        };

        return new HttpMessageInvoker(handler, disposeHandler: true);
    }
}
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/alnikola/reverse-proxy/blob/release/latest/docs/docfx/articles/http-client-config.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
